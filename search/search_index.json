{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is CoCo? Conversational Components make chatbot building easier by deconstructing conversations into components. All components hold context over multiple turns of conversation to better engage your users, with logic wired into the conversational flow. All you have to do is incorporate them into your bots. It\u2019s time to make the development of conversational A.I. a collaborative process. When you build on reusable and customizable parts, you create better chatbots to make conversation easy. You\u2019ll be able to stack a conversation with pre-built dialogue blocks. Each of these blocks maintains user context throughout the conversation. They\u2019re also reusable and customizable, saving you precious time by eliminating the need to create a dialogue management system from scratch for every new bot you build. And the best part? CoCos are simple to implement into any bot framework! For Chatbot Developers It's really easy to use Conversational Components in your chatbots. With CoCo, you can call components through a simple unified, REST format that is easy to embed in your chatbot. Moreover, you can view all of the components you are using in your user profile, which monitors the number of API requests, latency, and error rates, among other metrics. For more on using components, check out the Basics - Your First Component Call section or our CoCos for Developers page. For Component Vendors If you\u2019ve already built excellent components of your own, we make it simple for you to distribute and monetize it. Adding your component to CoCo's Marketplace offers you several benefits. You\u2019ll get instant exposure to our growing user base, a search-engine-optimized profile page for your component, as well as features like user management and billing services. For more on adding your component, visit our Adding & Managing components - Getting Started section or check out our Components Providers page.","title":"Overview"},{"location":"#what-is-coco","text":"Conversational Components make chatbot building easier by deconstructing conversations into components. All components hold context over multiple turns of conversation to better engage your users, with logic wired into the conversational flow. All you have to do is incorporate them into your bots. It\u2019s time to make the development of conversational A.I. a collaborative process. When you build on reusable and customizable parts, you create better chatbots to make conversation easy. You\u2019ll be able to stack a conversation with pre-built dialogue blocks. Each of these blocks maintains user context throughout the conversation. They\u2019re also reusable and customizable, saving you precious time by eliminating the need to create a dialogue management system from scratch for every new bot you build. And the best part? CoCos are simple to implement into any bot framework!","title":"What is CoCo?"},{"location":"#for-chatbot-developers","text":"It's really easy to use Conversational Components in your chatbots. With CoCo, you can call components through a simple unified, REST format that is easy to embed in your chatbot. Moreover, you can view all of the components you are using in your user profile, which monitors the number of API requests, latency, and error rates, among other metrics. For more on using components, check out the Basics - Your First Component Call section or our CoCos for Developers page.","title":"For Chatbot Developers"},{"location":"#for-component-vendors","text":"If you\u2019ve already built excellent components of your own, we make it simple for you to distribute and monetize it. Adding your component to CoCo's Marketplace offers you several benefits. You\u2019ll get instant exposure to our growing user base, a search-engine-optimized profile page for your component, as well as features like user management and billing services. For more on adding your component, visit our Adding & Managing components - Getting Started section or check out our Components Providers page.","title":"For Component Vendors"},{"location":"SDKs/","text":"Python ( github ) NodeJS ( github ) Rasa ( github ) Cognigy ( github )","title":"SDKs"},{"location":"SDKs/#python","text":"( github )","title":"Python"},{"location":"SDKs/#nodejs","text":"( github )","title":"NodeJS"},{"location":"SDKs/#rasa","text":"( github )","title":"Rasa"},{"location":"SDKs/#cognigy","text":"( github )","title":"Cognigy"},{"location":"api/","text":"window.onload = function () { // Begin Swagger UI call region const ui = SwaggerUIBundle({ url: \"/openapi.yaml\", //Location of Open API spec in the repo dom_id: '#swagger-ui', deepLinking: true, presets: [ SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset ], plugins: [ SwaggerUIBundle.plugins.DownloadUrl ], }) window.ui = ui }","title":"API Specs"},{"location":"connectors/","text":"Toolkits to expose components with our unified API Dialogflow ( github ) Rasa ( github ) Cognigy ( github ) Houndify ( github )","title":"Vendor Toolkits"},{"location":"connectors/#dialogflow","text":"( github )","title":"Dialogflow"},{"location":"connectors/#rasa","text":"( github )","title":"Rasa"},{"location":"connectors/#cognigy","text":"( github )","title":"Cognigy"},{"location":"connectors/#houndify","text":"( github )","title":"Houndify"},{"location":"vendor-guidelines/","text":"The component should address a single task or conversation topic The component must comply with the CoCo API, terms and conditions The component must be able to manage the calls to and from the component (control protocol) The component must use the context/updated_context/context transfer standard correctly The vendor should provide a clear description and goal of the component The component must be be available for calls 24/7. Minimum uptime of over 95%. The Component must be self-contained - handle the conversation from beginning to end Parameters passed by the component must be relevant to the component\u2019s goal The Component should be able to understand inputs which are relevant to the component goal (within reason), and identify inputs not relevant to the component goal The vendor must expose all bot responses for lingual customization The component must be GDPR compliant.","title":"Publishing guidelines"},{"location":"tutorials/authors_videos/","text":"Building a component on Rasa Create a conversational component using Rasa Building a component on Dialogflow Create a conversational component using Dialogflow Building a component on Cognigy Create a conversational component using Cognigy. How to become a Vendor and submit a new CoCo","title":"CoCo Vendors"},{"location":"tutorials/authors_videos/#building-a-component-on-rasa","text":"Create a conversational component using Rasa","title":"Building a component on Rasa"},{"location":"tutorials/authors_videos/#building-a-component-on-dialogflow","text":"Create a conversational component using Dialogflow","title":"Building a component on Dialogflow"},{"location":"tutorials/authors_videos/#building-a-component-on-cognigy","text":"Create a conversational component using Cognigy.","title":"Building a component on Cognigy"},{"location":"tutorials/authors_videos/#how-to-become-a-vendor-and-submit-a-new-coco","text":"","title":"How to become a Vendor and submit a new CoCo"},{"location":"tutorials/developer_videos/","text":"Add a fallback CoCo to your Rasa bot How to integrate a Conversational Component (CoCo) in the Rasa Fallback trigger. Calling a CoCo from a Dialogflow bot Calling a CoCo from a Rasa bot Calling a CoCo from a Cognigy bot Use multiple CoCos in a Cognigy bot","title":"Bot Developers"},{"location":"tutorials/developer_videos/#add-a-fallback-coco-to-your-rasa-bot","text":"How to integrate a Conversational Component (CoCo) in the Rasa Fallback trigger.","title":"Add a fallback CoCo to your Rasa bot"},{"location":"tutorials/developer_videos/#calling-a-coco-from-a-dialogflow-bot","text":"","title":"Calling a CoCo from a Dialogflow bot"},{"location":"tutorials/developer_videos/#calling-a-coco-from-a-rasa-bot","text":"","title":"Calling a CoCo from a Rasa bot"},{"location":"tutorials/developer_videos/#calling-a-coco-from-a-cognigy-bot","text":"","title":"Calling a CoCo from a Cognigy bot"},{"location":"tutorials/developer_videos/#use-multiple-cocos-in-a-cognigy-bot","text":"","title":"Use multiple CoCos in a Cognigy bot"},{"location":"tutorials/rasa/","text":"","title":"Rasa"},{"location":"tutorials/use_a_component_with_dialogflow_external/","text":"Calling a CoCo from Dialogflow(Externally) In the following tutorial we'll build a banking bot, using Dialogflow banking prebuilt agent and CoCo the 'Register' component from the CoCo Marketplace . I'll guide you thorough the whole process, including the implementation of the CoCo 'Register' component. Setup Prebuilt Bot On Dialogflow: Create a Dialogflow account. Go to the prebuilt agents menu: Choose banking agent: Import banking agent: Authentication With Dialogflow(Service Account Key): Extract agent service account key: Go to agent settings. Go to service accounts: Generate JSON key: Place it in code sample directory as service_accout.json: Code Sample Overview: We'll use a Flask application to expose our bot throut an API. For communication with Dialogflow we'll use Dialogflow SDK and for communication with the CoCo component we'll use CoCo SDK. Code to code sample repository: https://github.com/ConversationalComponents/webinar/tree/master/py Flow: Global Variable current_comp: MAIN_COMP = \"default\" # Current component on which the session is running. current_comp = MAIN_COMP The current_comp global variable will be \"default\" when the conversation is controlled by Dialogflow. When the control is passed to a CoCo component the value of the current_comp variable will be the CoCo component ID which is in control of the conversation right now. CoCo And Dialogflow Access Functions: Dialogflow and CoCo request wrapped with process functions. Let's take a look at the process_dialogflow function: def process_dialogflow ( session_id , text , language_code = \"en\" ): \"\"\" Returns bot output for user input. Using the same `session_id` between requests allows continuation of the conversation. Arguments: session_id (string): Current session ID. text (string): User input. language_code (string): Context language. Returns: Return tuple intent_name, bot_output (tuple). \"\"\" session = session_client . session_path ( project_id , session_id ) text_input = dialogflow . types . TextInput ( text = text , language_code = language_code ) query_input = dialogflow . types . QueryInput ( text = text_input ) response = session_client . detect_intent ( session = session , query_input = query_input ) return response . query_result . intent . display_name , response . query_result . fulfillment_text The function receives the session_id and user input then returns intent display name and response text. And there is the process_coco function: def process_coco ( component_id , session_id , input_text ): \"\"\" Process user input at a coco component. Arguments: component_id (string): Target component ID. session_id (string): Target session ID. input_text (string): User input text. Returns: CoCo component output. (string) \"\"\" component = ConversationalComponent ( component_id ) return component ( session_id = session_id , user_input = input_text ) The function receives CoCo component ID, session ID and user input. The answer will be the component output. /input Endpoint: At the our app.py file we will implement /input endpoint, which will receive user_input at the payload process the input and return bot response.(Will be implemented at the \"implement Component In Conversation Flow\" topic.) Choose And Add Component: Access marketplace: https://marketplace.conversationalcomponents.com/ Choose the 'Register' component: Add Component: Implement Component In Conversation Flow: @app . route ( \"/input\" , methods = [ \"POST\" ]) def get_input (): global current_comp request_data = request . get_json () or {} user_input = request_data . get ( \"user_input\" ) Send user input to Dialogflow. # Get response from DialogFlow for user input. intent_name , bot_output = process_dialogflow ( session_id = CURRENT_SESSION_ID , text = user_input ) Choose a relevant intent which will trigger the control pass to a CoCo component: The relevant intent for registration is \"account.open\". # If catch intent, give control to CoCo component. if intent_name == \"account.open\" : current_comp = \"register_vp3\" if current_comp == \"register_vp3\" : # Fetch response from CoCo if intent catch. coco_response = process_coco ( component_id = \"register_vp3\" , session_id = CURRENT_SESSION_ID , input_text = user_input ) When component is done, pass the conversation control back to Dialogflow: # If component done, return the control to the main flow. if coco_response . component_done : current_comp = MAIN_COMP bot_output = coco_response . response return jsonify ({ \"response\" : bot_output }), 200 , {} Run And Test The Bot: pip install -r requirements.txt flask run try the bot at 127.0.0.1:5000","title":"Calling a CoCo from Dialogflow(Externally)"},{"location":"tutorials/use_a_component_with_dialogflow_external/#calling-a-coco-from-dialogflowexternally","text":"In the following tutorial we'll build a banking bot, using Dialogflow banking prebuilt agent and CoCo the 'Register' component from the CoCo Marketplace . I'll guide you thorough the whole process, including the implementation of the CoCo 'Register' component.","title":"Calling a CoCo from Dialogflow(Externally)"},{"location":"tutorials/use_a_component_with_dialogflow_external/#setup-prebuilt-bot-on-dialogflow","text":"Create a Dialogflow account. Go to the prebuilt agents menu: Choose banking agent: Import banking agent:","title":"Setup Prebuilt Bot On Dialogflow:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#authentication-with-dialogflowservice-account-key","text":"Extract agent service account key: Go to agent settings. Go to service accounts: Generate JSON key: Place it in code sample directory as service_accout.json:","title":"Authentication With Dialogflow(Service Account Key):"},{"location":"tutorials/use_a_component_with_dialogflow_external/#code-sample-overview","text":"We'll use a Flask application to expose our bot throut an API. For communication with Dialogflow we'll use Dialogflow SDK and for communication with the CoCo component we'll use CoCo SDK. Code to code sample repository: https://github.com/ConversationalComponents/webinar/tree/master/py","title":"Code Sample Overview:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#flow","text":"","title":"Flow:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#global-variable-current_comp","text":"MAIN_COMP = \"default\" # Current component on which the session is running. current_comp = MAIN_COMP The current_comp global variable will be \"default\" when the conversation is controlled by Dialogflow. When the control is passed to a CoCo component the value of the current_comp variable will be the CoCo component ID which is in control of the conversation right now.","title":"Global Variable current_comp:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#coco-and-dialogflow-access-functions","text":"Dialogflow and CoCo request wrapped with process functions. Let's take a look at the process_dialogflow function: def process_dialogflow ( session_id , text , language_code = \"en\" ): \"\"\" Returns bot output for user input. Using the same `session_id` between requests allows continuation of the conversation. Arguments: session_id (string): Current session ID. text (string): User input. language_code (string): Context language. Returns: Return tuple intent_name, bot_output (tuple). \"\"\" session = session_client . session_path ( project_id , session_id ) text_input = dialogflow . types . TextInput ( text = text , language_code = language_code ) query_input = dialogflow . types . QueryInput ( text = text_input ) response = session_client . detect_intent ( session = session , query_input = query_input ) return response . query_result . intent . display_name , response . query_result . fulfillment_text The function receives the session_id and user input then returns intent display name and response text. And there is the process_coco function: def process_coco ( component_id , session_id , input_text ): \"\"\" Process user input at a coco component. Arguments: component_id (string): Target component ID. session_id (string): Target session ID. input_text (string): User input text. Returns: CoCo component output. (string) \"\"\" component = ConversationalComponent ( component_id ) return component ( session_id = session_id , user_input = input_text ) The function receives CoCo component ID, session ID and user input. The answer will be the component output.","title":"CoCo And Dialogflow Access Functions:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#input-endpoint","text":"At the our app.py file we will implement /input endpoint, which will receive user_input at the payload process the input and return bot response.(Will be implemented at the \"implement Component In Conversation Flow\" topic.)","title":"/input Endpoint:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#choose-and-add-component","text":"Access marketplace: https://marketplace.conversationalcomponents.com/ Choose the 'Register' component: Add Component:","title":"Choose And Add Component:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#implement-component-in-conversation-flow","text":"@app . route ( \"/input\" , methods = [ \"POST\" ]) def get_input (): global current_comp request_data = request . get_json () or {} user_input = request_data . get ( \"user_input\" ) Send user input to Dialogflow. # Get response from DialogFlow for user input. intent_name , bot_output = process_dialogflow ( session_id = CURRENT_SESSION_ID , text = user_input ) Choose a relevant intent which will trigger the control pass to a CoCo component: The relevant intent for registration is \"account.open\". # If catch intent, give control to CoCo component. if intent_name == \"account.open\" : current_comp = \"register_vp3\" if current_comp == \"register_vp3\" : # Fetch response from CoCo if intent catch. coco_response = process_coco ( component_id = \"register_vp3\" , session_id = CURRENT_SESSION_ID , input_text = user_input ) When component is done, pass the conversation control back to Dialogflow: # If component done, return the control to the main flow. if coco_response . component_done : current_comp = MAIN_COMP bot_output = coco_response . response return jsonify ({ \"response\" : bot_output }), 200 , {}","title":"Implement Component In Conversation Flow:"},{"location":"tutorials/use_a_component_with_dialogflow_external/#run-and-test-the-bot","text":"pip install -r requirements.txt flask run try the bot at 127.0.0.1:5000","title":"Run And Test The Bot:"},{"location":"tutorials/videos/","text":"Introduction to the CoCo Marketplace Introduction to the Conversational Component Marketplace. Learn how to share Chatbot Components. Customizing A Component How to customize the response texts of a Conversational Component to match your bot's language and personality. Next Steps Use a CoCo in your bot Build a new Component","title":"Marketplace"},{"location":"tutorials/videos/#introduction-to-the-coco-marketplace","text":"Introduction to the Conversational Component Marketplace. Learn how to share Chatbot Components.","title":"Introduction to the CoCo Marketplace"},{"location":"tutorials/videos/#customizing-a-component","text":"How to customize the response texts of a Conversational Component to match your bot's language and personality.","title":"Customizing A Component"},{"location":"tutorials/videos/#next-steps","text":"Use a CoCo in your bot Build a new Component","title":"Next Steps"}]}